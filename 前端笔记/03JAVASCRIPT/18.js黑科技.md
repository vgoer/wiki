<center>Js 黑科技 </center>



[toc]







## js 黑科技

> 记录一些前端的黑科技技术





### 1. 获取电池信息

> 获取电池信息 [blog](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651615139&idx=1&sn=d59472bceac228d96f835194269d0218&chksm=8022b862b7553174fd6fcfa7e58639720579cefe83a96ba0efd4158bf5ccfbabfa07a1fe25e1#rd)
>
> Battery Status API的使用
>
> Battery Status API 是一个 Web API，允许 Web 应用程序访问用户设备的电池状态信息。使用这个 API，我们可以在不安装任何应用程序的情况下，从 Web 浏览器直接读取设备的电量信息。

```js
// 请求电池信息
navigator.getBattery().then(function (battery) {
    // 后续代码
    // 获取设备电量剩余百分比
    var level = battery.level //最大值为1,对应电量100%
    console.log('Level: ' + level * 100 + '%')

    // 获取设备充电状态
    var charging = battery.charging
    console.log('充电状态: ' + charging)

    // 获取设备完全充电需要的时间
    var chargingTime = battery.chargingTime
    console.log('完全充电需要的时间: ' + chargingTime)

    // 获取设备完全放电需要的时间
    var dischargingTime = battery.dischargingTime
    console.log('完全放电需要的时间: ' + dischargingTime)


    // 添加事件，当设备电量改变时触发
    battery.addEventListener('levelchange', function () {
        console.log('电量改变: ' + battery.level)
    })

    // 添加事件，当设备充电状态改变时触发
    battery.addEventListener('chargingchange', function () {
        console.log('充电状态改变: ' + battery.charging)
    })

    // 添加事件，当设备完全充电需要时间改变时触发
    battery.addEventListener('chargingtimechange', function () {
        console.log('完全充电需要时间: ' + battery.chargingTime)
    })

    // 添加事件，当设备完全放电需要时间改变时触发
    battery.addEventListener('dischargingtimechange', function () {
        console.log('完全放电需要时间: ' + battery.dischargingTime)
    })

})
```

> 大声: ==牛皮==





### 2. 全屏API

> Fullscreen API 让一个原生全屏显示

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>web</title>
    <style>
        /* WebKit 没有这样做，相反地，它将全屏元素居中，不改变大小，而屏幕的其他部分为黑色。 */
        #myvideo:-webkit-full-screen {
            width: 100%;
            height: 100%;
            background: #fff;
        }
    </style>
</head>
<body>

    <!-- <div id="myvideo">hello</div> -->

    <video style="width: 400px; height: 400px;" controls id="myvideo" >
        <source src="flower.webm"></source>
        <source src="flower.mp4"></source>
    </video>
    <button onclick="manageFullscreen()">full</button>

    <script>

        let manageFullscreen = () => {
            console.log(1)
            document.getElementById('myvideo').requestFullscreen();
        }

        let elem = document.getElementById('myvideo')
        document.addEventListener("keydown", function(e) {
        if (e.keyCode == 13) {
            toggleFullScreen();
        }
        }, false);
        
        // 浏览器前缀
        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.mozFullScreenElement &&
                !document.webkitFullscreenElement && !document.msFullscreenElement) {
                // 进入全屏模式
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                // 退出全屏模式
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

    </script>
</body>
</html>
```





### 3. 获取剪切板API

> Clipboard Async API 是一个现代的 Web API，用于在浏览器中读取和写入剪贴板内容。

```html
<input type="text" id="get_to">
    <button id="get_btn">复制</button>

    <input type="text" id="put_to">
    <button id="put_btn">粘贴</button>

    <script>
        let get_btn = document.getElementById('get_btn');
        let put_btn = document.getElementById('put_btn');

        // 点击复制按钮时触发事件
        get_btn.addEventListener('click', async () => {
            let get_to = document.getElementById('get_to').value;
            try {
                await navigator.clipboard.writeText(get_to);
                console.log(`${get_to} copied to clipboard`);
            } catch (err) {
                console.error('Failed to copy: ', err);
            }
        });

        // 点击粘贴按钮时触发事件
        put_btn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('put_to').value = text;
                console.log('Pasted content: ', text);
            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
            }
        });

        // 检查剪贴板支持
        if (navigator.clipboard && navigator.clipboard.read && navigator.clipboard.write) {
            console.log("剪贴板操作被支持");
        } else {
            console.log("剪贴板操作不被支持");
        }
    </script>
```



### 4. 监控原生变化API

> Resize Observer API 是一个用于监听元素大小变化的 JavaScript API。
>
> 很多自己修改圆角，盒子阴影等网站应用的技术

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resize Observer API</title>

    <style>
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 300px;
            height: 300px;
            border: 2px solid black;
        }

        #box {
            width: 100px;
            height: 100px;
            background-color: red;
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="box"></div>
    </div>
    <br>
    <input type="range" id="rangeInput" min="0" max="200" value="100">
    
    <script>
        let box = document.getElementById('box');
        let rangeInput = document.getElementById('rangeInput');

        function resizeBox() {
            let boxSize = rangeInput.value + 'px';
            box.style.width = boxSize;
            box.style.height = boxSize;
            box.style.border = `${boxSize} solid black`
        }

        let resizeObserver = new ResizeObserver(resizeBox);

        resizeObserver.observe(box);
        resizeBox(); // 初始调整一次盒子大小

        rangeInput.addEventListener('input', function() {
            resizeBox();
        });
    </script>
</body>
</html>
```




### 5. 多媒体API

> 获取摄像头 录制视频和拍照
>
> Image Capture API 是一个用于从摄像头或其他视频源捕获图像的 JavaScript API。
>
> MediaRecorder API 是一种在 Web 浏览器中进行音频和视频录制的 API。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Capture API Example</title>
</head>
<body>
    <video id="video" width="640" height="480" autoplay></video>
    <button id="captureBtn">Capture Image</button>
    <button id="recordBtn">Start Recording</button>
    <button id="stopBtn">Stop Recording</button>

    <script>
        // 获取 video 元素和 capture、record、stop 按钮元素
        var video = document.getElementById('video');
        var captureBtn = document.getElementById('captureBtn');
        var recordBtn = document.getElementById('recordBtn');
        var stopBtn = document.getElementById('stopBtn');

        // 定义变量用于存储 MediaRecorder 和录制的视频数据
        var mediaRecorder;
        var recordedChunks = [];

        // 获取摄像头视频流
        navigator.mediaDevices.getUserMedia({ video: true })
        .then(function(stream) {
            video.srcObject = stream;
            mediaRecorder = new MediaRecorder(stream);

            // 添加数据到 recordedChunks 数组
            mediaRecorder.addEventListener('dataavailable', function(e) {
            if (e.data.size > 0) {
                recordedChunks.push(e.data);
            }
            });

            // 完成录制后处理视频数据
            mediaRecorder.addEventListener('stop', function() {
            // 创建 Blob 对象包含录制的视频数据
            var blob = new Blob(recordedChunks, { type: 'video/webm' });

            // 创建一个临时 URL 并显示在页面上
            var videoElement = document.createElement('video');
            videoElement.src = URL.createObjectURL(blob);
            videoElement.controls = true;
            videoElement.autoplay = true;
            document.body.appendChild(videoElement);

            // 清空 recordedChunks 数组
            recordedChunks = [];
            });
        })
        .catch(function(error) {
            console.log('获取视频流失败:', error);
        });

        // 当点击 capture 按钮时触发
        captureBtn.addEventListener('click', function() {
        // 创建 ImageCapture 实例
        var imageCapture = new ImageCapture(video.srcObject.getVideoTracks()[0]);

        // 捕获图像
        imageCapture.takePhoto()
            .then(function(blob) {
            // 图像捕获成功，创建一个临时 URL 并显示在页面上
            var img = document.createElement('img');
            img.src = URL.createObjectURL(blob);
            document.body.appendChild(img);
            })
            .catch(function(error) {
            console.log('图像捕获失败:', error);
            });
        });

        // 当点击 record 按钮时触发
        recordBtn.addEventListener('click', function() {
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        recordedChunks = [];

        // 开始录制
        mediaRecorder.start();
        });

        // 当点击 stop 按钮时触发
        stopBtn.addEventListener('click', function() {
        recordBtn.disabled = false;
        stopBtn.disabled = true;

        // 停止录制
        mediaRecorder.stop();
        });
    </script>
</body>
</html>
```





### 6. 屏幕录制和截屏

> 录制屏幕和截屏
>
> 1. MediaRecorder API：用于屏幕录制，可以录制屏幕上的视频和音频。
> 2. Screen Capture API：用于屏幕截屏，可以获取屏幕上的图像数据。

```html
<!DOCTYPE html>
<html>
<head>
    <title>屏幕录制和截屏示例</title>
</head>
<body>
    <button id="startRecordBtn">开始录制</button>
    <button id="stopRecordBtn">停止录制</button>
    <br>
    <video id="videoPlayer" controls></video>
    <br>
    <button id="captureBtn">截屏</button>
    <canvas id="screenshotCanvas"></canvas>

    <script>
        var startRecordBtn = document.getElementById('startRecordBtn');
        var stopRecordBtn = document.getElementById('stopRecordBtn');
        var captureBtn = document.getElementById('captureBtn');
        var videoPlayer = document.getElementById('videoPlayer');
        var screenshotCanvas = document.getElementById('screenshotCanvas');
        var mediaRecorder;
        var recordedChunks = [];

        // 开始录制
        startRecordBtn.addEventListener('click', function() {
        navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
            .then(function(stream) {
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.addEventListener('dataavailable', function(e) {
                if (e.data.size > 0) {
                recordedChunks.push(e.data);
                }
            });

            mediaRecorder.addEventListener('stop', function() {
                var blob = new Blob(recordedChunks, { type: 'video/webm' });
                videoPlayer.src = URL.createObjectURL(blob);
            });

            mediaRecorder.start();

            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            })
            .catch(function(error) {
            console.log('获取屏幕共享流失败:', error);
            });
        });

        // 停止录制
        stopRecordBtn.addEventListener('click', function() {
        mediaRecorder.stop();

        startRecordBtn.disabled = false;
        stopRecordBtn.disabled = true;
        });

        // 截屏
        captureBtn.addEventListener('click', function() {
        navigator.mediaDevices.getDisplayMedia({ video: true })
            .then(function(stream) {
            var videoTrack = stream.getVideoTracks()[0];
            var imageCapture = new ImageCapture(videoTrack);

            imageCapture.grabFrame()
                .then(function(imageBitmap) {
                screenshotCanvas.width = imageBitmap.width;
                screenshotCanvas.height = imageBitmap.height;

                var context = screenshotCanvas.getContext('2d');
                context.drawImage(imageBitmap, 0, 0);

                // 显示截屏结果
                var screenshotImage = new Image();
                screenshotImage.src = screenshotCanvas.toDataURL();
                document.body.appendChild(screenshotImage);
                })
                .catch(function(error) {
                console.log('截屏失败:', error);
                });
            })
            .catch(function(error) {
            console.log('获取屏幕共享流失败:', error);
            });
        });
    </script>
</body>
</html>
```





### 7. 同源的多个浏览器窗口通信

> Broadcast Channel API 是一种用于在==同源==的多个浏览器窗口或标签页之间进行通信的 API。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Broadcast Channel API 示例</title>
</head>
<body>
    <h1>主窗口</h1>
    <input type="text" id="messageInput">
    <button id="sendMessageBtn">发送消息</button>

    <script>
        var messageInput = document.getElementById('messageInput');
        var sendMessageBtn = document.getElementById('sendMessageBtn');
        var channel = new BroadcastChannel('myChannel');

        // 发送消息
        sendMessageBtn.addEventListener('click', function() {
        var message = messageInput.value;
        channel.postMessage(message);
        });

        // 接收消息
        channel.addEventListener('message', function(event) {
        var message = event.data;
        console.log('接收到消息:', message);
        });
    </script>
</body>
</html>
```

```html
// 另一个页面
<script>
        var channel = new BroadcastChannel('myChannel');
        
        // 接收消息
        channel.addEventListener('message', function(event) {
            var message = event.data;
            console.log('接收到消息:', message);
        });
 </script>
```







