<center>Js 黑科技 </center>



[toc]







## js 黑科技

> 记录一些前端的黑科技技术





### 1. 获取电池信息

> 获取电池信息 [blog](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651615139&idx=1&sn=d59472bceac228d96f835194269d0218&chksm=8022b862b7553174fd6fcfa7e58639720579cefe83a96ba0efd4158bf5ccfbabfa07a1fe25e1#rd)
>
> Battery Status API的使用
>
> Battery Status API 是一个 Web API，允许 Web 应用程序访问用户设备的电池状态信息。使用这个 API，我们可以在不安装任何应用程序的情况下，从 Web 浏览器直接读取设备的电量信息。

```js
// 请求电池信息
navigator.getBattery().then(function (battery) {
    // 后续代码
    // 获取设备电量剩余百分比
    var level = battery.level //最大值为1,对应电量100%
    console.log('Level: ' + level * 100 + '%')

    // 获取设备充电状态
    var charging = battery.charging
    console.log('充电状态: ' + charging)

    // 获取设备完全充电需要的时间
    var chargingTime = battery.chargingTime
    console.log('完全充电需要的时间: ' + chargingTime)

    // 获取设备完全放电需要的时间
    var dischargingTime = battery.dischargingTime
    console.log('完全放电需要的时间: ' + dischargingTime)


    // 添加事件，当设备电量改变时触发
    battery.addEventListener('levelchange', function () {
        console.log('电量改变: ' + battery.level)
    })

    // 添加事件，当设备充电状态改变时触发
    battery.addEventListener('chargingchange', function () {
        console.log('充电状态改变: ' + battery.charging)
    })

    // 添加事件，当设备完全充电需要时间改变时触发
    battery.addEventListener('chargingtimechange', function () {
        console.log('完全充电需要时间: ' + battery.chargingTime)
    })

    // 添加事件，当设备完全放电需要时间改变时触发
    battery.addEventListener('dischargingtimechange', function () {
        console.log('完全放电需要时间: ' + battery.dischargingTime)
    })

})
```

> 大声: ==牛皮==





### 2. 全屏API

> Fullscreen API 让一个原生全屏显示

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>web</title>
    <style>
        /* WebKit 没有这样做，相反地，它将全屏元素居中，不改变大小，而屏幕的其他部分为黑色。 */
        #myvideo:-webkit-full-screen {
            width: 100%;
            height: 100%;
            background: #fff;
        }
    </style>
</head>
<body>

    <!-- <div id="myvideo">hello</div> -->

    <video style="width: 400px; height: 400px;" controls id="myvideo" >
        <source src="flower.webm"></source>
        <source src="flower.mp4"></source>
    </video>
    <button onclick="manageFullscreen()">full</button>

    <script>

        let manageFullscreen = () => {
            console.log(1)
            document.getElementById('myvideo').requestFullscreen();
        }

        let elem = document.getElementById('myvideo')
        document.addEventListener("keydown", function(e) {
        if (e.keyCode == 13) {
            toggleFullScreen();
        }
        }, false);
        
        // 浏览器前缀
        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.mozFullScreenElement &&
                !document.webkitFullscreenElement && !document.msFullscreenElement) {
                // 进入全屏模式
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                // 退出全屏模式
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

    </script>
</body>
</html>
```





### 3. 获取剪切板API

> Clipboard Async API 是一个现代的 Web API，用于在浏览器中读取和写入剪贴板内容。

```html
<input type="text" id="get_to">
    <button id="get_btn">复制</button>

    <input type="text" id="put_to">
    <button id="put_btn">粘贴</button>

    <script>
        let get_btn = document.getElementById('get_btn');
        let put_btn = document.getElementById('put_btn');

        // 点击复制按钮时触发事件
        get_btn.addEventListener('click', async () => {
            let get_to = document.getElementById('get_to').value;
            try {
                await navigator.clipboard.writeText(get_to);
                console.log(`${get_to} copied to clipboard`);
            } catch (err) {
                console.error('Failed to copy: ', err);
            }
        });

        // 点击粘贴按钮时触发事件
        put_btn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('put_to').value = text;
                console.log('Pasted content: ', text);
            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
            }
        });

        // 检查剪贴板支持
        if (navigator.clipboard && navigator.clipboard.read && navigator.clipboard.write) {
            console.log("剪贴板操作被支持");
        } else {
            console.log("剪贴板操作不被支持");
        }
    </script>
```



### 4. 监控原生变化API

> Resize Observer API 是一个用于监听元素大小变化的 JavaScript API。
>
> 很多自己修改圆角，盒子阴影等网站应用的技术

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resize Observer API</title>

    <style>
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 300px;
            height: 300px;
            border: 2px solid black;
        }

        #box {
            width: 100px;
            height: 100px;
            background-color: red;
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="box"></div>
    </div>
    <br>
    <input type="range" id="rangeInput" min="0" max="200" value="100">
    
    <script>
        let box = document.getElementById('box');
        let rangeInput = document.getElementById('rangeInput');

        function resizeBox() {
            let boxSize = rangeInput.value + 'px';
            box.style.width = boxSize;
            box.style.height = boxSize;
            box.style.border = `${boxSize} solid black`
        }

        let resizeObserver = new ResizeObserver(resizeBox);

        resizeObserver.observe(box);
        resizeBox(); // 初始调整一次盒子大小

        rangeInput.addEventListener('input', function() {
            resizeBox();
        });
    </script>
</body>
</html>
```




### 5. 多媒体API

> 获取摄像头 录制视频和拍照
>
> Image Capture API 是一个用于从摄像头或其他视频源捕获图像的 JavaScript API。
>
> MediaRecorder API 是一种在 Web 浏览器中进行音频和视频录制的 API。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Capture API Example</title>
</head>
<body>
    <video id="video" width="640" height="480" autoplay></video>
    <button id="captureBtn">Capture Image</button>
    <button id="recordBtn">Start Recording</button>
    <button id="stopBtn">Stop Recording</button>

    <script>
        // 获取 video 元素和 capture、record、stop 按钮元素
        var video = document.getElementById('video');
        var captureBtn = document.getElementById('captureBtn');
        var recordBtn = document.getElementById('recordBtn');
        var stopBtn = document.getElementById('stopBtn');

        // 定义变量用于存储 MediaRecorder 和录制的视频数据
        var mediaRecorder;
        var recordedChunks = [];

        // 获取摄像头视频流
        navigator.mediaDevices.getUserMedia({ video: true })
        .then(function(stream) {
            video.srcObject = stream;
            mediaRecorder = new MediaRecorder(stream);

            // 添加数据到 recordedChunks 数组
            mediaRecorder.addEventListener('dataavailable', function(e) {
            if (e.data.size > 0) {
                recordedChunks.push(e.data);
            }
            });

            // 完成录制后处理视频数据
            mediaRecorder.addEventListener('stop', function() {
            // 创建 Blob 对象包含录制的视频数据
            var blob = new Blob(recordedChunks, { type: 'video/webm' });

            // 创建一个临时 URL 并显示在页面上
            var videoElement = document.createElement('video');
            videoElement.src = URL.createObjectURL(blob);
            videoElement.controls = true;
            videoElement.autoplay = true;
            document.body.appendChild(videoElement);

            // 清空 recordedChunks 数组
            recordedChunks = [];
            });
        })
        .catch(function(error) {
            console.log('获取视频流失败:', error);
        });

        // 当点击 capture 按钮时触发
        captureBtn.addEventListener('click', function() {
        // 创建 ImageCapture 实例
        var imageCapture = new ImageCapture(video.srcObject.getVideoTracks()[0]);

        // 捕获图像
        imageCapture.takePhoto()
            .then(function(blob) {
            // 图像捕获成功，创建一个临时 URL 并显示在页面上
            var img = document.createElement('img');
            img.src = URL.createObjectURL(blob);
            document.body.appendChild(img);
            })
            .catch(function(error) {
            console.log('图像捕获失败:', error);
            });
        });

        // 当点击 record 按钮时触发
        recordBtn.addEventListener('click', function() {
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        recordedChunks = [];

        // 开始录制
        mediaRecorder.start();
        });

        // 当点击 stop 按钮时触发
        stopBtn.addEventListener('click', function() {
        recordBtn.disabled = false;
        stopBtn.disabled = true;

        // 停止录制
        mediaRecorder.stop();
        });
    </script>
</body>
</html>
```





### 6. 屏幕录制和截屏

> 录制屏幕和截屏
>
> 1. MediaRecorder API：用于屏幕录制，可以录制屏幕上的视频和音频。
> 2. Screen Capture API：用于屏幕截屏，可以获取屏幕上的图像数据。

```html
<!DOCTYPE html>
<html>
<head>
    <title>屏幕录制和截屏示例</title>
</head>
<body>
    <button id="startRecordBtn">开始录制</button>
    <button id="stopRecordBtn">停止录制</button>
    <br>
    <video id="videoPlayer" controls></video>
    <br>
    <button id="captureBtn">截屏</button>
    <canvas id="screenshotCanvas"></canvas>

    <script>
        var startRecordBtn = document.getElementById('startRecordBtn');
        var stopRecordBtn = document.getElementById('stopRecordBtn');
        var captureBtn = document.getElementById('captureBtn');
        var videoPlayer = document.getElementById('videoPlayer');
        var screenshotCanvas = document.getElementById('screenshotCanvas');
        var mediaRecorder;
        var recordedChunks = [];

        // 开始录制
        startRecordBtn.addEventListener('click', function() {
        navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
            .then(function(stream) {
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.addEventListener('dataavailable', function(e) {
                if (e.data.size > 0) {
                recordedChunks.push(e.data);
                }
            });

            mediaRecorder.addEventListener('stop', function() {
                var blob = new Blob(recordedChunks, { type: 'video/webm' });
                videoPlayer.src = URL.createObjectURL(blob);
            });

            mediaRecorder.start();

            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            })
            .catch(function(error) {
            console.log('获取屏幕共享流失败:', error);
            });
        });

        // 停止录制
        stopRecordBtn.addEventListener('click', function() {
        mediaRecorder.stop();

        startRecordBtn.disabled = false;
        stopRecordBtn.disabled = true;
        });

        // 截屏
        captureBtn.addEventListener('click', function() {
        navigator.mediaDevices.getDisplayMedia({ video: true })
            .then(function(stream) {
            var videoTrack = stream.getVideoTracks()[0];
            var imageCapture = new ImageCapture(videoTrack);

            imageCapture.grabFrame()
                .then(function(imageBitmap) {
                screenshotCanvas.width = imageBitmap.width;
                screenshotCanvas.height = imageBitmap.height;

                var context = screenshotCanvas.getContext('2d');
                context.drawImage(imageBitmap, 0, 0);

                // 显示截屏结果
                var screenshotImage = new Image();
                screenshotImage.src = screenshotCanvas.toDataURL();
                document.body.appendChild(screenshotImage);
                })
                .catch(function(error) {
                console.log('截屏失败:', error);
                });
            })
            .catch(function(error) {
            console.log('获取屏幕共享流失败:', error);
            });
        });
    </script>
</body>
</html>
```





### 7. 同源的多个浏览器窗口通信

> Broadcast Channel API 是一种用于在==同源==的多个浏览器窗口或标签页之间进行通信的 API。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Broadcast Channel API 示例</title>
</head>
<body>
    <h1>主窗口</h1>
    <input type="text" id="messageInput">
    <button id="sendMessageBtn">发送消息</button>

    <script>
        var messageInput = document.getElementById('messageInput');
        var sendMessageBtn = document.getElementById('sendMessageBtn');
        var channel = new BroadcastChannel('myChannel');

        // 发送消息
        sendMessageBtn.addEventListener('click', function() {
        var message = messageInput.value;
        channel.postMessage(message);
        });

        // 接收消息
        channel.addEventListener('message', function(event) {
        var message = event.data;
        console.log('接收到消息:', message);
        });
    </script>
</body>
</html>
```

```html
// 另一个页面
<script>
        var channel = new BroadcastChannel('myChannel');
        
        // 接收消息
        channel.addEventListener('message', function(event) {
            var message = event.data;
            console.log('接收到消息:', message);
        });
 </script>
```





### 8. 设备震动

> Vibration API 是一个用于在支持的设备上触发震动的接口。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Vibration API 示例</title>
</head>
<body>
    <h1>触发震动</h1>

    <button id="vibrateBtn">开始震动</button>

    <script>
        let vibrateBtn = document.getElementById('vibrateBtn');

        vibrateBtn.addEventListener('click', function() {
        if (navigator.vibrate) {
            // 支持 Vibration API
            navigator.vibrate(2000); // 2秒的震动
            console.log(1)
            // navigator.vibrate([1000, 500, 2000]); // 1秒震动，暂停0.5秒，再震动2秒
        } else {
            console.log('该设备不支持震动功能');
        }
        });
    </script>
</body>
</html>
```





### 9. 蓝牙里连接

> Bluetooth API 是一个用于在网页中与蓝牙设备进行通信的接口。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Bluetooth API 示例</title>
</head>
<body>
    <h1>蓝牙设备连接</h1>

    <button id="searchBtn">搜索蓝牙设备</button>
    <div id="deviceList"></div>

    <script>
        var searchBtn = document.getElementById('searchBtn');
        var deviceListDiv = document.getElementById('deviceList');

        searchBtn.addEventListener('click', function() {
        navigator.bluetooth.requestDevice({ filters: [{ services: ['battery_service'] }] })
            .then(function(device) {
            // 成功找到设备
            console.log('已找到设备:', device.name);

            // 连接设备
            return device.gatt.connect();
            })
            .then(function(server) {
            // 成功连接到 GATT 服务器
            console.log('已连接到 GATT 服务器');

            // 获取服务
            return server.getPrimaryService('battery_service');
            })
            .then(function(service) {
            // 获取特征
            return service.getCharacteristic('battery_level');
            })
            .then(function(characteristic) {
            // 读取特征值
            return characteristic.readValue();
            })
            .then(function(value) {
            // 读取到特征值
            var batteryLevel = value.getUint8(0);
            console.log('电池电量:', batteryLevel + '%');
            })
            .catch(function(error) {
            console.log('发生错误:', error);
            });
        });
    </script>
</body>
</html>
```



### 10. 桌面显示通知

> `Notification` API  构造函数用于创建桌面通知对象

```html
<!DOCTYPE html>
<html>
<head>
    <title>发送桌面通知示例</title>
</head>
<body>
    <button onclick="requestNotificationPermission()">发送通知</button>

    <script>
        function requestNotificationPermission() {
        if (Notification.permission !== 'granted') {
            Notification.requestPermission().then(function(permission) {
            if (permission === 'granted') {
                showNotification();
            }
            });
        } else {
            showNotification();
        }
        }

        function showNotification() {
        var notification = new Notification('提示标题', {
            body: '提示内容',
            icon: 'path/to/icon.png'
        });

        notification.onclick = function() {
            window.focus();
            notification.close();
        };

        setTimeout(function() {
            notification.close();
        }, 5000);
        }
    </script>
</body>
</html>
```





### 11. 语言识别和朗读

> Web Speech API 是一组浏览器提供的 API，用于实现语音识别和语音合成功能。
>
> 1. SpeechRecognition 接口：用于实现语音识别功能，将用户的语音输入转换为文本。
> 2. SpeechSynthesis 接口：用于实现语音合成功能，将文本转换为语音输出。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Web Speech API 示例</title>
</head>
<body>
    <button onclick="startRecognition()">开始语音识别</button>
    <button onclick="stopRecognition()">停止语音识别</button>
    <button onclick="speakText()">朗读文本</button>

    <script>
        var recognition = new webkitSpeechRecognition(); // 创建 SpeechRecognition 实例

        function startRecognition() {
            recognition.start(); // 开始语音识别
        }

        function stopRecognition() {
            recognition.stop(); // 停止语音识别
        }

        recognition.onresult = function(event) {
        var transcript = event.results[0][0].transcript; // 获取识别到的文本
        console.log('识别结果: ' + transcript);
        }

        recognition.onerror = function(event) {
        console.error('语音识别错误：' + event.error);
        }

        function speakText() {
        var synthesis = window.speechSynthesis; // 获取 SpeechSynthesis 实例

        var utterance = new SpeechSynthesisUtterance('要朗读的文本'); // 创建 Utterance 对象
        synthesis.speak(utterance); // 开始朗读
        }
    </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html>
<head>
    <title>单词朗读</title>
</head>
<body>
    <input type="text" id="wordInput">
    <button onclick="speakWord()">朗读</button>

    <script>
        function speakWord() {
        var word = document.getElementById('wordInput').value;

        if ('speechSynthesis' in window) {
            var utterance = new SpeechSynthesisUtterance(word);
            speechSynthesis.speak(utterance);
        } else {
            alert('浏览器不支持语音合成功能');
        }
        }
    </script>
</body>
</html>
```





### 12. 拖放事件

> 对元素进行拖放

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        .drag-element {
        width: 100px;
        height: 100px;
        background-color: red;
        color: white;
        text-align: center;
        line-height: 100px;
        cursor: move;
        }
        .drop-zone {
        width: 200px;
        height: 200px;
        border: 2px dashed #ccc;
        }
    </style>
</head>
<body>
    <div id="dragElement" class="drag-element" draggable="true">Drag me</div>
    <div id="dropZone" class="drop-zone">Drop zone</div>

    <script>
        var dragElement = document.getElementById("dragElement");
        var dropZone = document.getElementById("dropZone");

        // 拖动开始时触发的事件处理程序
        dragElement.addEventListener("dragstart", function(event) {
        // 设置被拖动的数据（可选）
        event.dataTransfer.setData("text/plain", event.target.id);
        });

        // 拖动进入目标区域时触发的事件处理程序
        dropZone.addEventListener("dragenter", function(event) {
        // 阻止默认的拖动事件行为
        event.preventDefault();

        // 添加一个类名以反映目标区域正在被拖动进入
        dropZone.classList.add("dragover");
        });

        // 拖动离开目标区域时触发的事件处理程序
        dropZone.addEventListener("dragleave", function(event) {
        // 移除表示拖动进入的类名
        dropZone.classList.remove("dragover");
        });

        // 拖动在目标区域上方移动时触发的事件处理程序
        dropZone.addEventListener("dragover", function(event) {
        // 阻止默认的拖动事件行为
        event.preventDefault();
        });

        // 放下拖动的元素时触发的事件处理程序
        dropZone.addEventListener("drop", function(event) {
        // 阻止默认的拖放事件行为
        event.preventDefault();

        // 移除表示拖动进入的类名
        dropZone.classList.remove("dragover");

        // 获取拖动的数据
        var draggedElementId = event.dataTransfer.getData("text/plain");
        var draggedElement = document.getElementById(draggedElementId);

        // 将拖动的元素添加到目标区域
        dropZone.appendChild(draggedElement);
        });
    </script>
</body>
</html>
```





### 13. 获取网络信息

> Network Information API: 提供了更详细的网络信息

```js
if ('connection' in navigator) {
    const connection = navigator.connection;
    console.log('有效类型:', connection.effectiveType);
    console.log('下行带宽估计值（Mbps）:', connection.downlink);
    console.log('上行带宽估计值（Mbps）:', connection.uplink);
    console.log('往返时间估计值（ms）:', connection.rtt);
    console.log('连接类型:', connection.type);

    // 监听网络变化
    connection.addEventListener('change', () => {
        console.log('网络状态变化');
        console.log('新的有效类型:', connection.effectiveType);
        console.log('新的下行带宽估计值（Mbps）:', connection.downlink);
        console.log('新的上行带宽估计值（Mbps）:', connection.uplink);
        console.log('新的往返时间估计值（ms）:', connection.rtt);
        console.log('新的连接类型:', connection.type);
    });
}
```

