<center>Js 黑科技 </center>



[toc]







## js 黑科技

> 记录一些前端的黑科技技术





### 1. 获取电池信息

> 获取电池信息 [blog](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651615139&idx=1&sn=d59472bceac228d96f835194269d0218&chksm=8022b862b7553174fd6fcfa7e58639720579cefe83a96ba0efd4158bf5ccfbabfa07a1fe25e1#rd)
>
> Battery Status API的使用
>
> Battery Status API 是一个 Web API，允许 Web 应用程序访问用户设备的电池状态信息。使用这个 API，我们可以在不安装任何应用程序的情况下，从 Web 浏览器直接读取设备的电量信息。

```js
// 请求电池信息
navigator.getBattery().then(function (battery) {
    // 后续代码
    // 获取设备电量剩余百分比
    var level = battery.level //最大值为1,对应电量100%
    console.log('Level: ' + level * 100 + '%')

    // 获取设备充电状态
    var charging = battery.charging
    console.log('充电状态: ' + charging)

    // 获取设备完全充电需要的时间
    var chargingTime = battery.chargingTime
    console.log('完全充电需要的时间: ' + chargingTime)

    // 获取设备完全放电需要的时间
    var dischargingTime = battery.dischargingTime
    console.log('完全放电需要的时间: ' + dischargingTime)


    // 添加事件，当设备电量改变时触发
    battery.addEventListener('levelchange', function () {
        console.log('电量改变: ' + battery.level)
    })

    // 添加事件，当设备充电状态改变时触发
    battery.addEventListener('chargingchange', function () {
        console.log('充电状态改变: ' + battery.charging)
    })

    // 添加事件，当设备完全充电需要时间改变时触发
    battery.addEventListener('chargingtimechange', function () {
        console.log('完全充电需要时间: ' + battery.chargingTime)
    })

    // 添加事件，当设备完全放电需要时间改变时触发
    battery.addEventListener('dischargingtimechange', function () {
        console.log('完全放电需要时间: ' + battery.dischargingTime)
    })

})
```

> 大声: ==牛皮==





### 2. 全屏API

> Fullscreen API 让一个原生全屏显示

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>web</title>
    <style>
        /* WebKit 没有这样做，相反地，它将全屏元素居中，不改变大小，而屏幕的其他部分为黑色。 */
        #myvideo:-webkit-full-screen {
            width: 100%;
            height: 100%;
            background: #fff;
        }
    </style>
</head>
<body>

    <!-- <div id="myvideo">hello</div> -->

    <video style="width: 400px; height: 400px;" controls id="myvideo" >
        <source src="flower.webm"></source>
        <source src="flower.mp4"></source>
    </video>
    <button onclick="manageFullscreen()">full</button>

    <script>

        let manageFullscreen = () => {
            console.log(1)
            document.getElementById('myvideo').requestFullscreen();
        }

        let elem = document.getElementById('myvideo')
        document.addEventListener("keydown", function(e) {
        if (e.keyCode == 13) {
            toggleFullScreen();
        }
        }, false);
        
        // 浏览器前缀
        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.mozFullScreenElement &&
                !document.webkitFullscreenElement && !document.msFullscreenElement) {
                // 进入全屏模式
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                // 退出全屏模式
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

    </script>
</body>
</html>
```





### 3. 获取剪切板API

> Clipboard Async API 是一个现代的 Web API，用于在浏览器中读取和写入剪贴板内容。

```html
<input type="text" id="get_to">
    <button id="get_btn">复制</button>

    <input type="text" id="put_to">
    <button id="put_btn">粘贴</button>

    <script>
        let get_btn = document.getElementById('get_btn');
        let put_btn = document.getElementById('put_btn');

        // 点击复制按钮时触发事件
        get_btn.addEventListener('click', async () => {
            let get_to = document.getElementById('get_to').value;
            try {
                await navigator.clipboard.writeText(get_to);
                console.log(`${get_to} copied to clipboard`);
            } catch (err) {
                console.error('Failed to copy: ', err);
            }
        });

        // 点击粘贴按钮时触发事件
        put_btn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('put_to').value = text;
                console.log('Pasted content: ', text);
            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
            }
        });

        // 检查剪贴板支持
        if (navigator.clipboard && navigator.clipboard.read && navigator.clipboard.write) {
            console.log("剪贴板操作被支持");
        } else {
            console.log("剪贴板操作不被支持");
        }
    </script>
```



### 4. 监控原生变化API

> Resize Observer API 是一个用于监听元素大小变化的 JavaScript API。
>
> 很多自己修改圆角，盒子阴影等网站应用的技术

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resize Observer API</title>

    <style>
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 300px;
            height: 300px;
            border: 2px solid black;
        }

        #box {
            width: 100px;
            height: 100px;
            background-color: red;
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="box"></div>
    </div>
    <br>
    <input type="range" id="rangeInput" min="0" max="200" value="100">
    
    <script>
        let box = document.getElementById('box');
        let rangeInput = document.getElementById('rangeInput');

        function resizeBox() {
            let boxSize = rangeInput.value + 'px';
            box.style.width = boxSize;
            box.style.height = boxSize;
            box.style.border = `${boxSize} solid black`
        }

        let resizeObserver = new ResizeObserver(resizeBox);

        resizeObserver.observe(box);
        resizeBox(); // 初始调整一次盒子大小

        rangeInput.addEventListener('input', function() {
            resizeBox();
        });
    </script>
</body>
</html>
```




### 5. 多媒体API

> 获取摄像头 录制视频和拍照
>
> Image Capture API 是一个用于从摄像头或其他视频源捕获图像的 JavaScript API。
>
> MediaRecorder API 是一种在 Web 浏览器中进行音频和视频录制的 API。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Capture API Example</title>
</head>
<body>
    <video id="video" width="640" height="480" autoplay></video>
    <button id="captureBtn">Capture Image</button>
    <button id="recordBtn">Start Recording</button>
    <button id="stopBtn">Stop Recording</button>

    <script>
        // 获取 video 元素和 capture、record、stop 按钮元素
        var video = document.getElementById('video');
        var captureBtn = document.getElementById('captureBtn');
        var recordBtn = document.getElementById('recordBtn');
        var stopBtn = document.getElementById('stopBtn');

        // 定义变量用于存储 MediaRecorder 和录制的视频数据
        var mediaRecorder;
        var recordedChunks = [];

        // 获取摄像头视频流
        navigator.mediaDevices.getUserMedia({ video: true })
        .then(function(stream) {
            video.srcObject = stream;
            mediaRecorder = new MediaRecorder(stream);

            // 添加数据到 recordedChunks 数组
            mediaRecorder.addEventListener('dataavailable', function(e) {
            if (e.data.size > 0) {
                recordedChunks.push(e.data);
            }
            });

            // 完成录制后处理视频数据
            mediaRecorder.addEventListener('stop', function() {
            // 创建 Blob 对象包含录制的视频数据
            var blob = new Blob(recordedChunks, { type: 'video/webm' });

            // 创建一个临时 URL 并显示在页面上
            var videoElement = document.createElement('video');
            videoElement.src = URL.createObjectURL(blob);
            videoElement.controls = true;
            videoElement.autoplay = true;
            document.body.appendChild(videoElement);

            // 清空 recordedChunks 数组
            recordedChunks = [];
            });
        })
        .catch(function(error) {
            console.log('获取视频流失败:', error);
        });

        // 当点击 capture 按钮时触发
        captureBtn.addEventListener('click', function() {
        // 创建 ImageCapture 实例
        var imageCapture = new ImageCapture(video.srcObject.getVideoTracks()[0]);

        // 捕获图像
        imageCapture.takePhoto()
            .then(function(blob) {
            // 图像捕获成功，创建一个临时 URL 并显示在页面上
            var img = document.createElement('img');
            img.src = URL.createObjectURL(blob);
            document.body.appendChild(img);
            })
            .catch(function(error) {
            console.log('图像捕获失败:', error);
            });
        });

        // 当点击 record 按钮时触发
        recordBtn.addEventListener('click', function() {
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        recordedChunks = [];

        // 开始录制
        mediaRecorder.start();
        });

        // 当点击 stop 按钮时触发
        stopBtn.addEventListener('click', function() {
        recordBtn.disabled = false;
        stopBtn.disabled = true;

        // 停止录制
        mediaRecorder.stop();
        });
    </script>
</body>
</html>
```





### 6. 屏幕录制和截屏

> 录制屏幕和截屏
>
> 1. MediaRecorder API：用于屏幕录制，可以录制屏幕上的视频和音频。
> 2. Screen Capture API：用于屏幕截屏，可以获取屏幕上的图像数据。

```html
<!DOCTYPE html>
<html>
<head>
    <title>屏幕录制和截屏示例</title>
</head>
<body>
    <button id="startRecordBtn">开始录制</button>
    <button id="stopRecordBtn">停止录制</button>
    <br>
    <video id="videoPlayer" controls></video>
    <br>
    <button id="captureBtn">截屏</button>
    <canvas id="screenshotCanvas"></canvas>

    <script>
        var startRecordBtn = document.getElementById('startRecordBtn');
        var stopRecordBtn = document.getElementById('stopRecordBtn');
        var captureBtn = document.getElementById('captureBtn');
        var videoPlayer = document.getElementById('videoPlayer');
        var screenshotCanvas = document.getElementById('screenshotCanvas');
        var mediaRecorder;
        var recordedChunks = [];

        // 开始录制
        startRecordBtn.addEventListener('click', function() {
        navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
            .then(function(stream) {
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.addEventListener('dataavailable', function(e) {
                if (e.data.size > 0) {
                recordedChunks.push(e.data);
                }
            });

            mediaRecorder.addEventListener('stop', function() {
                var blob = new Blob(recordedChunks, { type: 'video/webm' });
                videoPlayer.src = URL.createObjectURL(blob);
            });

            mediaRecorder.start();

            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            })
            .catch(function(error) {
            console.log('获取屏幕共享流失败:', error);
            });
        });

        // 停止录制
        stopRecordBtn.addEventListener('click', function() {
        mediaRecorder.stop();

        startRecordBtn.disabled = false;
        stopRecordBtn.disabled = true;
        });

        // 截屏
        captureBtn.addEventListener('click', function() {
        navigator.mediaDevices.getDisplayMedia({ video: true })
            .then(function(stream) {
            var videoTrack = stream.getVideoTracks()[0];
            var imageCapture = new ImageCapture(videoTrack);

            imageCapture.grabFrame()
                .then(function(imageBitmap) {
                screenshotCanvas.width = imageBitmap.width;
                screenshotCanvas.height = imageBitmap.height;

                var context = screenshotCanvas.getContext('2d');
                context.drawImage(imageBitmap, 0, 0);

                // 显示截屏结果
                var screenshotImage = new Image();
                screenshotImage.src = screenshotCanvas.toDataURL();
                document.body.appendChild(screenshotImage);
                })
                .catch(function(error) {
                console.log('截屏失败:', error);
                });
            })
            .catch(function(error) {
            console.log('获取屏幕共享流失败:', error);
            });
        });
    </script>
</body>
</html>
```





### 7. 同源的多个浏览器窗口通信

> Broadcast Channel API 是一种用于在==同源==的多个浏览器窗口或标签页之间进行通信的 API。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Broadcast Channel API 示例</title>
</head>
<body>
    <h1>主窗口</h1>
    <input type="text" id="messageInput">
    <button id="sendMessageBtn">发送消息</button>

    <script>
        var messageInput = document.getElementById('messageInput');
        var sendMessageBtn = document.getElementById('sendMessageBtn');
        var channel = new BroadcastChannel('myChannel');

        // 发送消息
        sendMessageBtn.addEventListener('click', function() {
        var message = messageInput.value;
        channel.postMessage(message);
        });

        // 接收消息
        channel.addEventListener('message', function(event) {
        var message = event.data;
        console.log('接收到消息:', message);
        });
    </script>
</body>
</html>
```

```html
// 另一个页面
<script>
        var channel = new BroadcastChannel('myChannel');
        
        // 接收消息
        channel.addEventListener('message', function(event) {
            var message = event.data;
            console.log('接收到消息:', message);
        });
 </script>
```





### 8. 设备震动

> Vibration API 是一个用于在支持的设备上触发震动的接口。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Vibration API 示例</title>
</head>
<body>
    <h1>触发震动</h1>

    <button id="vibrateBtn">开始震动</button>

    <script>
        let vibrateBtn = document.getElementById('vibrateBtn');

        vibrateBtn.addEventListener('click', function() {
        if (navigator.vibrate) {
            // 支持 Vibration API
            navigator.vibrate(2000); // 2秒的震动
            console.log(1)
            // navigator.vibrate([1000, 500, 2000]); // 1秒震动，暂停0.5秒，再震动2秒
        } else {
            console.log('该设备不支持震动功能');
        }
        });
    </script>
</body>
</html>
```





### 9. 蓝牙里连接

> Bluetooth API 是一个用于在网页中与蓝牙设备进行通信的接口。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Bluetooth API 示例</title>
</head>
<body>
    <h1>蓝牙设备连接</h1>

    <button id="searchBtn">搜索蓝牙设备</button>
    <div id="deviceList"></div>

    <script>
        var searchBtn = document.getElementById('searchBtn');
        var deviceListDiv = document.getElementById('deviceList');

        searchBtn.addEventListener('click', function() {
        navigator.bluetooth.requestDevice({ filters: [{ services: ['battery_service'] }] })
            .then(function(device) {
            // 成功找到设备
            console.log('已找到设备:', device.name);

            // 连接设备
            return device.gatt.connect();
            })
            .then(function(server) {
            // 成功连接到 GATT 服务器
            console.log('已连接到 GATT 服务器');

            // 获取服务
            return server.getPrimaryService('battery_service');
            })
            .then(function(service) {
            // 获取特征
            return service.getCharacteristic('battery_level');
            })
            .then(function(characteristic) {
            // 读取特征值
            return characteristic.readValue();
            })
            .then(function(value) {
            // 读取到特征值
            var batteryLevel = value.getUint8(0);
            console.log('电池电量:', batteryLevel + '%');
            })
            .catch(function(error) {
            console.log('发生错误:', error);
            });
        });
    </script>
</body>
</html>
```



### 10. 桌面显示通知

> `Notification` API  构造函数用于创建桌面通知对象

```html
<!DOCTYPE html>
<html>
<head>
    <title>发送桌面通知示例</title>
</head>
<body>
    <button onclick="requestNotificationPermission()">发送通知</button>

    <script>
        function requestNotificationPermission() {
        if (Notification.permission !== 'granted') {
            Notification.requestPermission().then(function(permission) {
            if (permission === 'granted') {
                showNotification();
            }
            });
        } else {
            showNotification();
        }
        }

        function showNotification() {
        var notification = new Notification('提示标题', {
            body: '提示内容',
            icon: 'path/to/icon.png'
        });

        notification.onclick = function() {
            window.focus();
            notification.close();
        };

        setTimeout(function() {
            notification.close();
        }, 5000);
        }
    </script>
</body>
</html>
```





### 11. 语言识别和朗读

> Web Speech API 是一组浏览器提供的 API，用于实现语音识别和语音合成功能。
>
> 1. SpeechRecognition 接口：用于实现语音识别功能，将用户的语音输入转换为文本。
> 2. SpeechSynthesis 接口：用于实现语音合成功能，将文本转换为语音输出。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Web Speech API 示例</title>
</head>
<body>
    <button onclick="startRecognition()">开始语音识别</button>
    <button onclick="stopRecognition()">停止语音识别</button>
    <button onclick="speakText()">朗读文本</button>

    <script>
        var recognition = new webkitSpeechRecognition(); // 创建 SpeechRecognition 实例

        function startRecognition() {
            recognition.start(); // 开始语音识别
        }

        function stopRecognition() {
            recognition.stop(); // 停止语音识别
        }

        recognition.onresult = function(event) {
        var transcript = event.results[0][0].transcript; // 获取识别到的文本
        console.log('识别结果: ' + transcript);
        }

        recognition.onerror = function(event) {
        console.error('语音识别错误：' + event.error);
        }

        function speakText() {
        var synthesis = window.speechSynthesis; // 获取 SpeechSynthesis 实例

        var utterance = new SpeechSynthesisUtterance('要朗读的文本'); // 创建 Utterance 对象
        synthesis.speak(utterance); // 开始朗读
        }
    </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html>
<head>
    <title>单词朗读</title>
</head>
<body>
    <input type="text" id="wordInput">
    <button onclick="speakWord()">朗读</button>

    <script>
        function speakWord() {
        var word = document.getElementById('wordInput').value;

        if ('speechSynthesis' in window) {
            var utterance = new SpeechSynthesisUtterance(word);
            speechSynthesis.speak(utterance);
        } else {
            alert('浏览器不支持语音合成功能');
        }
        }
    </script>
</body>
</html>
```





### 12. 拖放事件

> 对元素进行拖放

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        .drag-element {
        width: 100px;
        height: 100px;
        background-color: red;
        color: white;
        text-align: center;
        line-height: 100px;
        cursor: move;
        }
        .drop-zone {
        width: 200px;
        height: 200px;
        border: 2px dashed #ccc;
        }
    </style>
</head>
<body>
    <div id="dragElement" class="drag-element" draggable="true">Drag me</div>
    <div id="dropZone" class="drop-zone">Drop zone</div>

    <script>
        var dragElement = document.getElementById("dragElement");
        var dropZone = document.getElementById("dropZone");

        // 拖动开始时触发的事件处理程序
        dragElement.addEventListener("dragstart", function(event) {
        // 设置被拖动的数据（可选）
        event.dataTransfer.setData("text/plain", event.target.id);
        });

        // 拖动进入目标区域时触发的事件处理程序
        dropZone.addEventListener("dragenter", function(event) {
        // 阻止默认的拖动事件行为
        event.preventDefault();

        // 添加一个类名以反映目标区域正在被拖动进入
        dropZone.classList.add("dragover");
        });

        // 拖动离开目标区域时触发的事件处理程序
        dropZone.addEventListener("dragleave", function(event) {
        // 移除表示拖动进入的类名
        dropZone.classList.remove("dragover");
        });

        // 拖动在目标区域上方移动时触发的事件处理程序
        dropZone.addEventListener("dragover", function(event) {
        // 阻止默认的拖动事件行为
        event.preventDefault();
        });

        // 放下拖动的元素时触发的事件处理程序
        dropZone.addEventListener("drop", function(event) {
        // 阻止默认的拖放事件行为
        event.preventDefault();

        // 移除表示拖动进入的类名
        dropZone.classList.remove("dragover");

        // 获取拖动的数据
        var draggedElementId = event.dataTransfer.getData("text/plain");
        var draggedElement = document.getElementById(draggedElementId);

        // 将拖动的元素添加到目标区域
        dropZone.appendChild(draggedElement);
        });
    </script>
</body>
</html>
```





### 13. 获取网络信息

> Network Information API: 提供了更详细的网络信息

```js
if ('connection' in navigator) {
    const connection = navigator.connection;
    console.log('有效类型:', connection.effectiveType);
    console.log('下行带宽估计值（Mbps）:', connection.downlink);
    console.log('上行带宽估计值（Mbps）:', connection.uplink);
    console.log('往返时间估计值（ms）:', connection.rtt);
    console.log('连接类型:', connection.type);

    // 监听网络变化
    connection.addEventListener('change', () => {
        console.log('网络状态变化');
        console.log('新的有效类型:', connection.effectiveType);
        console.log('新的下行带宽估计值（Mbps）:', connection.downlink);
        console.log('新的上行带宽估计值（Mbps）:', connection.uplink);
        console.log('新的往返时间估计值（ms）:', connection.rtt);
        console.log('新的连接类型:', connection.type);
    });
}
```




### 14. 网络性能

> Performance Interface API（性能接口API）是一种用于测量和监控网页性能的JavaScript API。

```js
// 使用 Performance API 获取页面加载时间
const loadTime = window.performance.timing.domContentLoadedEventEnd - window.performance.timing.navigationStart;
console.log('页面加载时间：', loadTime, '毫秒');

// 使用 Performance API 获取资源加载时间
window.performance.getEntriesByType('resource').forEach((resource) => {
  console.log('资源加载时间：', resource.name, resource.duration, '毫秒');
});

// 使用 Performance API 监听用户交互延迟
window.addEventListener('click', () => {
  const interactionDelay = window.performance.now();
  console.log('用户交互延迟：', interactionDelay, '毫秒');
});
```



### 15. 监控Dom树的变化

> MutationObserver API是一种用于监听DOM树变化的JavaScript API。

```js
// 选择要观察变化的目标元素
const targetElement = document.getElementById('target');

// 创建一个MutationObserver实例
const observer = new MutationObserver((mutationsList, observer) => {
    // 遍历所有变化的mutation
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            // 子节点发生变化
            console.log('子节点发生变化');
            // 进行相应的处理
        } else if (mutation.type === 'attributes') {
            // 属性发生变化
            console.log('属性发生变化');
            // 进行相应的处理
        }
    }
});

// 配置观察选项
const config = { childList: true, attributes: true, subtree: true };

// 开始观察目标元素的变化
observer.observe(targetElement, config);

// 停止观察变化
// observer.disconnect();
```

> 包括子节点的添加、删除、属性的变化等。







### 16. 监听元素视口

> IntersectionObserver API是一种现代的JavaScript API，用于监听一个元素是否进入或离开浏览器的视口（viewport）区域。

```js
// 创建一个IntersectionObserver实例并指定回调函数
const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if(entry.isIntersecting) {
            // 当目标元素进入视口时触发的回调函数
            entry.target.classList.add('in-viewport');
            console.log('进入了')
        } else {
            // 当目标元素离开视口时触发的回调函数
            entry.target.classList.remove('in-viewport');
            console.log('离开了')
        }
    });
});

// 选择所有需要观察的目标元素
const targets = document.querySelectorAll('.box');
console.log(targets)
// 开始观察目标元素
targets.forEach(target => {
    observer.observe(target);
});
```

> 图片懒加载，无限滚动呀



### 17. 动画api

> requestAnimationFrame 是一个浏览器提供的 JavaScript API，用于在下一次重绘之前执行指定的动画函数。与使用定时器函数（比如 setTimeout 或 setInterval）相比，requestAnimationFrame 更加高效，并且能够和浏览器的刷新频率同步，提供更流畅的动画效果。

```js
// 获取需要操作的元素
const ball = document.getElementById('ball');

// 定义小球的初始位置、速度和加速度
let position = 0;
let velocity = 0;
const gravity = 0.2;

function animate() {
    // 清空画布
    // 在实际应用中，需要根据具体情况选择合适的清空方法

    // 更新小球的位置和速度
    position += velocity;
    velocity += gravity;

    // 如果小球触底，则反弹
    if (position >= window.innerHeight - ball.offsetHeight) {
        velocity = -velocity * 0.9; // 反弹系数
        position = window.innerHeight - ball.offsetHeight;
    }

    // 设置小球的位置
    ball.style.transform = `translateY(${position}px)`;

    // 如果小球还在动，继续下一帧动画
    if (velocity !== 0 || position !== window.innerHeight - ball.offsetHeight) {
        window.requestAnimationFrame(animate);
    }
}

// 启动动画
window.requestAnimationFrame(animate);
```

> wc: 牛皮 渲染十万条数据这些功能 平滑的滚动

```js
// 平滑的滚动到top
const scrollToTop = () => {
    const c = document.documentElement.scrollTop || document.body.scrollTop
    if (c > 0) {
        window.requestAnimationFrame(scrollToTop)
        window.scrollTo(0, c - c / 8)
    }
}
```





### 18. 获取地理位置

> Geolocation API是浏览器提供的一种用于获取用户地理位置信息的JavaScript API。它可以通过浏览器获取用户的经纬度坐标、海拔高度以及精确度等信息，以便在Web应用程序中根据地理位置提供个性化的服务。

```js
// 检测浏览器是否支持 Geolocation API
if ('geolocation' in navigator) {
    // 支持 Geolocation API
    // 获取地理位置信息
    navigator.geolocation.getCurrentPosition(
        position => {
            const latitude = position.coords.latitude;     // 纬度
            const longitude = position.coords.longitude;   // 经度
            const altitude = position.coords.altitude;     // 海拔高度（可选）
            const speed = position.coords.speed;           // 速度（可选）

            console.log('Latitude:', latitude);
            console.log('Longitude:', longitude);
            console.log('Altitude:', altitude);
            console.log('Speed:', speed);
        },
        error => {
            console.error('Error occurred. Error code:', error.code, 'Message:', error.message);
        }
    );
} else {
    // 不支持 Geolocation API
    console.error('Geolocation API not supported');
}
```





### 19. 游戏手柄

> Gamepad API 是一组浏览器提供的 JavaScript 接口，用于检测和响应游戏手柄设备（如控制器）的输入。通过 Gamepad API，你可以访问游戏手柄的按键、摇杆、触发器等输入信息，并对其进行处理。

```js
if ('getGamepads' in navigator) {
    // 支持 Gamepad API
    console.log('yes')
} else {
    // 不支持 Gamepad API
    console.error('Gamepad API not supported');
}
// 手柄连接
window.addEventListener('gamepadconnected', function(event) {
    const gamepad = event.gamepad;
    console.log('Gamepad connected:', gamepad.id);
});
// 手柄断开
window.addEventListener('gamepaddisconnected', function(event) {
    const gamepad = event.gamepad;
    console.log('Gamepad disconnected:', gamepad.id);
});

// 执行方法
function updateGamepadStatus() {
    //  获取当前连接的手柄信息
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];
        if (gamepad) {
            for (let j = 0; j < gamepad.buttons.length; j++) {
                const button = gamepad.buttons[j];
                if (button.pressed) {
                    console.log('Button', j, 'is pressed');
                }
            }
        }
    }
}

function gameLoop() {
    updateGamepadStatus();
    requestAnimationFrame(gameLoop);
}

gameLoop();
```





### 20. 编码

> Encoding API是Web API的一部分，它提供了一种将字符串转换为不同编码格式（如UTF-8、UTF-16、ISO-8859-1等）的方法。两个接口

> 1. TextEncoder： TextEncoder接口用于将字符串编码为字节流。它的常用方法是encode()，该方法接受一个字符串作为输入，并返回一个Uint8Array类型的数组，其中包含了编码后的字节数据。

```js
if ('TextEncoder' in window) {
    // 支持TextEncoder
    console.log('yes')
} else {
    // 不支持TextEncoder
}
// 创建一个新的TextEncoder对象
const encoder = new TextEncoder();

// 将字符串编码为字节流
const text = 'Hello, World!';
const encodedData = encoder.encode(text);

// 打印编码后的字节流
console.log(encodedData);
```

> 2. TextDecoder： TextDecoder接口用于将字节流解码为字符串。它的常用方法是decode()，该方法接受一个TypedArray或ArrayBuffer类型的输入，并返回相应的解码后的字符串。

```js
// 创建一个新的TextDecoder对象
const decoder = new TextDecoder();

// 将字节流解码为字符串
const encodedData = new Uint8Array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);
const decodedText = decoder.decode(encodedData);

// 打印解码后的字符串
console.log(decodedText);
```

> 它对于处理多种字符编码的需求非常有用，如传输数据、读取文件等场景.





### 21. 文件API

> File API是Web API的一部分，它提供了一种在Web应用程序中处理本地文件的方式。通过File API，你可以读取和操作用户选择的文件，并对其进行上传、下载、编辑等操作。

```html
<input type="file" id="fileInput">
<button onclick="readFile()">读取文件</button>
<button onclick="uploadFile()">上传文件</button>
<a id="downloadLink" href="#" download>下载文件</a>
<br>
<div id="fileContent"></div>


<script>
    function readFile() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];

        if (file) {
            const reader = new FileReader();

            reader.onload = function(event) {
                const content = event.target.result;
                const fileContentDiv = document.getElementById('fileContent');
                fileContentDiv.innerText = content;
            }

            reader.readAsText(file);
        }
    }

    function uploadFile() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];

        if (file) {
            const formData = new FormData();
            formData.append('file', file);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/upload', true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    // 上传成功后，生成可下载的URL
                    const downloadUrl = URL.createObjectURL(xhr.response);
                    const downloadLink = document.getElementById('downloadLink');
                    downloadLink.href = downloadUrl;
                    downloadLink.innerText = '点击下载文件';
                }
            };
            xhr.send(formData);
        }
    }

</script>
```



### 21. 键盘API

> Keyboard API是Web API的一部分，它提供了与键盘事件相关的功能和信息。使用Keyboard API，可以检测和响应用户的键盘输入

```js
<p>按下的键：</p>
<div id="keyInfo"></div>

<script>
    const keyInfoDiv = document.getElementById('keyInfo');

// keydown事件：按下键盘上的任意键时触发。
window.addEventListener('keydown', handleKeyDown);
// keyup事件：释放键盘上的任意键时触发。
window.addEventListener('keyup', handleKeyUp);

function handleKeyDown(event) {
    // event.key：获取按下或释放的键的值，例如 "Enter"、"A"、"Shift"等。
    const key = event.key;
    // event.keyCode：获取按下或释放的键的字符编码。
    const keyCode = event.keyCode;
    // KeyboardEvent.code：获取按下或释放的键的标准化编码。
    const code = event.code;
    // KeyboardEvent.shiftKey、KeyboardEvent.ctrlKey、KeyboardEvent.altKey、KeyboardEvent.metaKey：获取按下或释放的键是否同时按下shift、ctrl、alt或meta键。
    const shiftKey = event.shiftKey;
    const ctrlKey = event.ctrlKey;
    const altKey = event.altKey;
    const metaKey = event.metaKey;

    keyInfoDiv.textContent = `
                Key: ${key}
                KeyCode: ${keyCode}
                Code: ${code}
                Shift Key: ${shiftKey}
                Ctrl Key: ${ctrlKey}
                Alt Key: ${altKey}
                Meta Key: ${metaKey}
            `;
    console.log(keyInfoDiv.textContent)
}

function handleKeyUp(event) {
    keyInfoDiv.textContent = '';
}
</script>
```





### 22. 检测网站是否隐藏了

> Page Visibility API是一个用于检测网页可见性的JavaScript API。它提供了一种方式，允许开发者根据用户当前是否正在浏览网页来执行相应的操作。这可以用于改进性能、调整资源使用，或在用户离开页面时执行特定的逻辑。

> 1. `document.hidden`：返回一个布尔值，表示当前页面是否被隐藏（不可见）。
>
> 2. ```js
>    document.visibilityState
>    ```
>
>    ：表示当前页面的可见性状态，可能的值有：
>
>    - `"visible"`：页面完全可见。
>    - `"hidden"`：页面被隐藏。
>    - `"prerender"`：页面正在进行预渲染，用户还未看到。
>    - `"unloaded"`：页面已被卸载。

```html
<h1>Page Visibility Example</h1>

<script>
    document.addEventListener('visibilitychange', handleVisibilityChange);

    function handleVisibilityChange() {
        if (document.hidden) {
            console.log('页面被隐藏');
        } else {
            console.log('页面可见');
        }

        console.log('可见性状态:', document.visibilityState);
    }
</script>
```





### 23. 交互事件API

> UI Events API（用户界面事件API）是Web API的一部分，它提供了对用户界面交互事件的访问和控制。这些事件包括鼠标、键盘和触摸设备上的事件，以及与焦点、选择和输入相关的事件。
>
> 1. `click`：当用户单击元素时触发。
> 2. `dblclick`：当用户双击元素时触发。
> 3. `mouseenter`：当鼠标光标进入元素时触发。
> 4. `mouseleave`：当鼠标光标离开元素时触发。
> 5. `mousedown`：当鼠标按钮在元素上按下时触发。
> 6. `mouseup`：当鼠标按钮在元素上释放时触发。
> 7. `keydown`：当键盘上的键被按下时触发。
> 8. `keyup`：当键盘上的键被释放时触发。
> 9. `focus`：当元素获得焦点时触发。
> 10. `blur`：当元素失去焦点时触发。

```js
const button = document.getElementById('myButton');

button.addEventListener('click', handleClick);
button.addEventListener('mouseenter', handleMouseEnter);

function handleClick(event) {
    console.log('按钮被点击了！');
}

function handleMouseEnter(event) {
    console.log('鼠标进入按钮！');
}
```



### 24. URL API

> URL API（Uniform Resource Locator API）是一组Web API，它提供了一种用于解析、构建和操作URL（统一资源定位符）的方法和属性。URL是用于定位和标识互联网上资源的字符串。

```js
const urlString = 'https://www.example.com/search?q=javascript&sort=popular';

// 解析URL
const url = new URL(urlString);
console.log(url.protocol); // 输出：https:
console.log(url.host); // 输出：www.example.com
console.log(url.pathname); // 输出：/search
console.log(url.search); // 输出：?q=javascript&sort=popular

// 构建URL
url.pathname = '/articles';
url.searchParams.set('page', '1');
console.log(url.href); // 输出：https://www.example.com/articles?page=1&q=javascript&sort=popular

// 操作URL参数
console.log(url.searchParams.get('sort')); // 输出：popular
url.searchParams.delete('sort');
console.log(url.href); // 输出：https://www.example.com/articles?page=1&q=javascript

// 相对URL解析
const relativeUrl = new URL('/about', url);
console.log(relativeUrl.href); // 输出：https://www.example.com/about
```



### 25. 获取客户端设备和特性信息API

> User-Agent Client Hints API 是一个Web API，旨在提供一种更可靠和安全的方式来获取客户端设备和特性信息。传统上，开发人员通过解析 User-Agent 头部来获取这些信息，但这种方法存在不确定性和隐私问题。User-Agent Client Hints API 通过使用几种新的 HTTP 头部，使开发人员能够以一种标准化且更可靠的方式请求客户端信息。
>
> 1. `Sec-CH-UA`：这是一个由浏览器发送的请求头部，它包含了客户端的用户代理信息。通过检查该头部，开发人员可以获取设备、操作系统、浏览器等信息。
> 2. `Sec-CH-UA-Mobile`：这是一个指示客户端是否为移动设备的请求头部。开发人员可以根据此信息来优化移动设备上的网页体验。
> 3. `Sec-CH-UA-Full-Version`：这是一个包含完整版本号的请求头部，用于获取更详细的客户端版本信息。
> 4. `Sec-CH-UA-Platform`：这是一个指示客户端平台的请求头部，如 "Windows"、"Linux"、"Android" 等。

```js
if ('userAgentData' in navigator) {
    // 浏览器支持 User-Agent Client Hints API
    console.log('yes')
} else {
    // 浏览器不支持 User-Agent Client Hints API
}

const uaData = navigator.userAgentData;
console.log(uaData)
// 获取用户代理字符串
const userAgent = uaData.userAgent;
console.log(userAgent);

// 判断是否为移动设备
const isMobile = uaData.mobile;
console.log(isMobile);

// 获取完整的版本号
const fullVersion = uaData.fullVersion;
console.log(fullVersion);

// 获取平台信息
const platform = uaData.platform;
console.log(platform);
```

