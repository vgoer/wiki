<center>中间件</center>





[toc]







## 中间件

> 中间件（Middleware）是一种用于过滤 HTTP 请求的机制。它允许你在请求进入应用程序和响应发送到浏览器之间执行代码。中间件可以用于验证用户身份、记录日志、处理跨站点请求伪造 (CSRF)、权限控制等等。 ==重要的知识点==





### 1. 使用

1. 创建

```php
php artisan make:middleware CheckAdmin
```

2. 注册

```php
// 找到 app/Http/Kernel.php 文件，将中间件添加到 $routeMiddleware 数组中：
protected $routeMiddleware = [
    // 其他中间件...
    'cors' => \App\Http\Middleware\CorsMiddleware::class,
];
```

3. 使用

```php
Route::get('/example', [
    'middleware' => ['middleware1', 'middleware2'],
]);

Route::get('admin/dashboard', function () {
    // ...
})->middleware('auth', 'checkAdmin');
```





### 2. 常用

> 跨域中间件

```php
class CorsMiddleware
{
    /**
     * 处理传入的请求。
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        $headers = [
            'Access-Control-Allow-Origin' => '*',
            'Access-Control-Allow-Methods' => 'GET, POST, PUT, DELETE',
            'Access-Control-Allow-Headers' => 'Content-Type, Authorization',
        ];

        if ($request->isMethod('OPTIONS')) {
            return response()->json([], 200, $headers);
        }

        return $next($request)->withHeaders($headers);
    }
}
```

> 身份认证中间件

```php
class Authenticate
{
    public function handle($request, Closure $next)
    {
        if (!Auth::check()) {
            return redirect('/login');
        }

        return $next($request);
    }
}
```

> 请求日志

```php
class LogRequests
{
    public function handle($request, Closure $next)
    {
        Log::info('Request URI: ' . $request->getPathInfo());

        return $next($request);
    }
}
```

> 限制并发请求

```php
class RateLimit
{
    public function handle($request, Closure $next)
    {
        $ip = $request->ip();
        $limit = 100; // 每分钟限制请求数量
        $expiration = 60; // 限制持续时间（秒）

        $key = 'rate_limit:' . $ip;
        $count = Redis::get($key) ?: 0;

        if ($count >= $limit) {
            abort(429, 'Too Many Requests');
        }

        Redis::incr($key);
        Redis::expire($key, $expiration);

        return $next($request);
    }
}
```



> 检查token

```php
/**
     * @ 检查Token是否合法
     */
    public function handle($request, Closure $next)
    {
        
        $header = $request->header();
        
        if (empty($header['token'][0])) {
            echo error(510001);
            exit();
        }
        $token = $header['token'][0];
        $count = EnterpriseModel::where('token', $token)->count();
        if ($count == 0) {
            echo error(510002);
            exit();
        }
        $enterprise = EnterpriseModel::where('token', $token)->first();
        // if ($enterprise->status == 1) {
        //     echo error(510003);
        //     exit();
        // }

        if ($enterprise->status == 2) {
            echo error(510004);
            exit();
        }
        $request->merge([
            'token'                => $token,
            'enterprise_id'        => $enterprise->id,
            'enterprise_status'    => $enterprise->status,
            'enterprise_step'      => $enterprise->step,
            'enterprise_mobile'    => $enterprise->mobile,
            'enterprise_avatar'    => $enterprise->avatar,
            'enterprise_unread'    => $enterprise->unread,
            'enterprise_type'      => eType($enterprise->enterprise_type),
            'enterprise_name'      => $enterprise->enterprise_name,
            'enterprise_cert_type' => cType($enterprise->cert_type),
            'enterprise_cert_no'   => $enterprise->cert_no,
            'enterprise_area'      => $enterprise->area,
            'enterprise_address'   => $enterprise->address,
            'enterprise_license'   => $enterprise->license,
            'enterprise_permit'    => $enterprise->permit
        ]);
        return $next($request);
    }
```





