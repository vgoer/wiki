<center>网络服务</center>



[toc]







## 网络服务

> 提供更全面的网络服务。除了http.









### 1. TCP/UDP服务

> 框架默认提供创建 `TCP/UDP` 服务的能力。只需要进行简易的配置，便可使用。

> 启动： 暴露更多的端口

```shell
docker run --name hyperf -v /home/goer/docker_date/hyperf-skeleton:/data/project -p 9501:9501 -p 9502:9502 -p 9503:9503 -p 9504:9504 -it --privileged -u root --entrypoint /bin/sh hyperf/hyperf:8.1-alpine-v3.18-swoole
```



## [使用 TCP 服务](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=使用-tcp-服务)

### [创建 TcpServer 类](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=创建-tcpserver-类)

```php
<?php

declare(strict_types=1);

namespace App\Controller;

use Hyperf\Contract\OnReceiveInterface;

class TcpServer implements OnReceiveInterface
{
    public function onReceive($server, int $fd, int $reactorId, string $data): void
    {
        $server->send($fd, 'recv:' . $data);
    }
}

```

### [创建对应配置](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=创建对应配置)

```php
<?php

declare(strict_types=1);

use Hyperf\Server\Server;
use Hyperf\Server\Event;

return [
    // 以下删除了其他不相关的配置项
    'servers' => [
        [
            'name' => 'tcp',
            'type' => Server::SERVER_BASE,
            'host' => '0.0.0.0',
            'port' => 9504,
            'sock_type' => SWOOLE_SOCK_TCP,
           'callbacks' => [
                Event::ON_RECEIVE => [App\Controller\TcpController::class, 'onReceive'],
                Event::ON_CONNECT => [App\Controller\TcpController::class, 'onConnect'],
                Event::ON_CLOSE => [App\Controller\TcpController::class, 'onClose'],
            ],
            'settings' => [
                // 按需配置
            ],
        ],
    ],
];
```

> 控制器：

```php
<?php

declare(strict_types=1);

namespace App\Controller;

use Hyperf\Contract\OnReceiveInterface;
use Swoole\Server as SwooleServer;
use Hyperf\Server\Connection\Connection;
use Hyperf\Server\Connection\HyperfConnection;
use Hyperf\Server\Connection\Socket;

class TcpController implements OnReceiveInterface
{
    /**
     * 当 TCP 客户端连接进入时触发
     */
    public function onConnect(SwooleServer $server, int $fd, int $reactorId): void
    {
        // 可以在这里进行连接验证
        $clientInfo = $server->getClientInfo($fd);
        var_dump("TCP Client {$fd} connected", $clientInfo);
        
        // 发送欢迎消息
        $server->send($fd, "Welcome to TCP Server!\n");
    }

    /**
     * 当服务器收到来自 TCP 客户端的数据时触发
     * 注意：方法签名必须完全匹配接口定义
     * @param Connection|HyperfConnection|Socket|SwooleServer $server
     */
    public function onReceive($server, int $fd, int $reactorId, string $data): void
    {
        // 处理接收到的数据
        var_dump("Received from TCP Client {$fd}: {$data}");
        
        // 解析数据（假设是 JSON 格式）
        $message = json_decode($data, true);
        
        if (is_array($message)) {
            // 根据消息类型处理不同的业务逻辑
            switch ($message['type'] ?? '') {
                case 'ping':
                    $server->send($fd, json_encode([
                        'type' => 'pong',
                        'time' => time()
                    ]));
                    break;
                    
                case 'chat':
                    // 处理聊天消息
                    $server->send($fd, json_encode([
                        'type' => 'chat',
                        'message' => '收到消息：' . ($message['content'] ?? '')
                    ]));
                    break;
                    
                default:
                    // 处理未知类型的消息
                    $server->send($fd, json_encode([
                        'type' => 'error',
                        'message' => '未知的消息类型'
                    ]));
            }
        } else {
            // 处理非 JSON 格式的消息
            $server->send($fd, "收到消息：{$data}\n");
        }
    }

    /**
     * 当 TCP 客户端连接关闭时触发
     */
    public function onClose(SwooleServer $server, int $fd, int $reactorId): void
    {
        var_dump("TCP Client {$fd} closed");
        // 可以在这里进行连接关闭后的清理工作
    }
}

```

> nc连接数据

```shell
# 或使用 netcat 连接
nc localhost 9503

# 客户端发送json
{"type": "chat", "content": "Hello TCP Server!"}
```

> 牛皮。

### [实现客户端](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=实现客户端)

```php
<?php
$client = new Swoole\Client(SWOOLE_SOCK_TCP);

if (!$client->connect('127.0.0.1', 9503, -1)) {
    exit("连接失败: {$client->errCode}\n");
}

// 发送消息
$message = json_encode([
    'type' => 'chat',
    'content' => 'Hello from TCP Client!'
]);
$client->send($message);

// 接收响应
echo $client->recv();

$client->close();
```



## [使用 UDP 服务](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=使用-udp-服务)

> Docker 默认使用 TCP 协议来通信，如果你需要使用 UDP 协议，你需要通过配置 Docker 网络来实现。

```shell
docker run -p 9502:9502/udp <image-name>
```

### [创建 UdpServer 类](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=创建-udpserver-类)

> 如果没有 OnPacketInterface 接口文件，则可以不实现此接口，运行结果与实现接口一致，只要保证配置正确即可。

```php
<?php

declare(strict_types=1);

namespace App\Controller;

use Hyperf\Contract\OnPacketInterface;

class UdpServer implements OnPacketInterface
{
    public function onPacket($server, $data, $clientInfo): void
    {
        var_dump($clientInfo);
        $server->sendto($clientInfo['address'], $clientInfo['port'], 'Server：' . $data);
    }
}
```

### [创建对应配置](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=创建对应配置-1)

```php
<?php

declare(strict_types=1);

use Hyperf\Server\Server;
use Hyperf\Server\Event;

return [
    // 以下删除了其他不相关的配置项
    'servers' => [
        [
            'name' => 'udp',
            'type' => Server::SERVER_BASE,
            'host' => '0.0.0.0',
            'port' => 9505,
            'sock_type' => SWOOLE_SOCK_UDP,
            'callbacks' => [
                Event::ON_PACKET => [App\Controller\UdpController::class, 'onPacket'],
            ],
            'settings' => [
                // 按需配置
            ],
        ],
    ],
];
```

> udp启动

```shell
docker run --name hyperf \
  -v /home/goer/docker_date/hyperf-skeleton:/data/project \
  -p 9501:9501 \
  -p 9502:9502 \
  -p 9503:9503 \
  -p 9504:9504/udp \
  -it --privileged -u root \
  --entrypoint /bin/sh hyperf/hyperf:8.1-alpine-v3.18-swoole
```

> UdpController

```php
<?php
declare(strict_types=1);

namespace App\Controller;

use Hyperf\Contract\OnPacketInterface;
use Swoole\Server as SwooleServer;

class UdpController implements OnPacketInterface
{
    // 存储所有连接的客户端
    private array $clients = [];

    /**
     * 当服务器收到来自 UDP 客户端的数据时触发
     * @param SwooleServer $server
     * @param mixed $data
     * @param array $clientInfo
     */
    public function onPacket($server, $data, $clientInfo): void
    {
        $clientAddress = $clientInfo['address'];
        $clientPort = $clientInfo['port'];
        $clientKey = "{$clientAddress}:{$clientPort}";
        
        // 记录新的客户端
        if (!isset($this->clients[$clientKey])) {
            $this->clients[$clientKey] = $clientInfo;
        }
        
        var_dump("Received from UDP Client {$clientKey}: {$data}");
        
        $message = json_decode($data, true);
        
        if (is_array($message)) {
            switch ($message['type'] ?? '') {
                case 'ping':
                    $server->sendto(
                        $clientAddress,
                        $clientPort,
                        json_encode([
                            'type' => 'pong',
                            'time' => time()
                        ])
                    );
                    break;
                    
                case 'broadcast':
                    // 广播给所有记录的客户端
                    foreach ($this->clients as $key => $client) {
                        $server->sendto(
                            $client['address'],
                            $client['port'],
                            json_encode([
                                'type' => 'broadcast',
                                'message' => $message['content'] ?? '',
                                'from' => $clientKey
                            ])
                        );
                    }
                    break;
                    
                default:
                    $server->sendto(
                        $clientAddress,
                        $clientPort,
                        json_encode([
                            'type' => 'error',
                            'message' => '未知的消息类型'
                        ])
                    );
            }
        } else {
            $server->sendto(
                $clientAddress,
                $clientPort,
                "收到消息：{$data}\n"
            );
        }
    }
}
```

> `type=broadcast` 广播。

> 测试

```shell
# 连接多个udp
nc -u localhost 9504
nc -u localhost 9504
nc -u localhost 9504
nc -u localhost 9504

# 一个发送广播的type  其他客户端都可以收到。
{"type": "broadcast", "content": "Hello UDP Server!"}
```

> udp php 客户端。

```php
<?php
# 需要Swoole 扩展
$client = new Swoole\Client(SWOOLE_SOCK_UDP);

// 发送消息
$message = json_encode([
    'type' => 'broadcast',
    'content' => 'Hello from UDP Client!'
]);
$client->sendto('127.0.0.1', 9504, $message);

// 接收响应
$data = $client->recv();
echo $data;

$client->close();
```

> 让我们用 PHP 内置的 socket 函数来创建 UDP 客户端：
>
> 开启sockes扩展
>
> ```shell
> extension=sockets
> ```

```php
```



## [事件](https://hyperf.wiki/3.1/#/zh-cn/tcp-server?id=事件)

| 事件              | 备注             |
| ----------------- | ---------------- |
| Event::ON_CONNECT | 监听连接进入事件 |
| Event::ON_RECEIVE | 监听数据接收事件 |
| Event::ON_CLOSE   | 监听连接关闭事件 |
| Event::ON_PACKET  | UDP 数据接收事件 |





