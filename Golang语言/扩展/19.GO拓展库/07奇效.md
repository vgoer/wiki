<center>打开软件</center>





[toc]









## 打开软件

> go 奇效







### 1. 打开文件



```go
//  打开桌面软件
package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func main() {
	// 获取桌面文件夹路径
	desktopPath, err := GetDesktopPath()
	if err != nil {
		fmt.Println("无法获取桌面路径:", err)
		return
	}

	// 列出桌面上的文件
	files, err := ListFilesOnDesktop(desktopPath)
	if err != nil {
		fmt.Println("无法列出桌面文件:", err)
		return
	}

	// 找到要打开的文件并双击打开
	targetFileName := "home.csv" // 替换为您要打开的文件名
	for _, file := range files {
		if strings.EqualFold(file, targetFileName) {
			// 构建完整文件路径
			filePath := filepath.Join(desktopPath, file)
			fmt.Printf("正在打开文件：%s\n", filePath)

			// 执行文件
			cmd := exec.Command("cmd", "/C", "start", filePath)
			if err := cmd.Run(); err != nil {
				fmt.Printf("无法打开文件：%s\n", err)
			}
			return
		}
	}

	fmt.Printf("未找到文件：%s\n", targetFileName)
}

// 获取桌面文件夹路径
func GetDesktopPath() (string, error) {
	desktop, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(desktop, "Desktop"), nil
}

// 列出桌面上的文件
func ListFilesOnDesktop(path string) ([]string, error) {
	var files []string

	entries, err := os.ReadDir(path)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			files = append(files, entry.Name())
		}
	}

	return files, nil
}

```







### 2. 加密

> 加密数据

```go
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io/ioutil"
	"os"
)

// 加密
func encryptFile(key []byte, srcPath string, destPath string) error {
	data, err := ioutil.ReadFile(srcPath)
	if err != nil {
		return err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	ciphertext := make([]byte, aes.BlockSize+len(data))
	iv := ciphertext[:aes.BlockSize]
	if _, err := rand.Read(iv); err != nil {
		return err
	}

	stream := cipher.NewCTR(block, iv)
	stream.XORKeyStream(ciphertext[aes.BlockSize:], data)

	if err := ioutil.WriteFile(destPath, ciphertext, 0644); err != nil {
		return err
	}

	return nil
}

// 解密
func decryptFile(key []byte, srcPath string, destPath string) error {
	ciphertext, err := ioutil.ReadFile(srcPath)
	if err != nil {
		return err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	iv := ciphertext[:aes.BlockSize]
	data := ciphertext[aes.BlockSize:]

	stream := cipher.NewCTR(block, iv)
	stream.XORKeyStream(data, data)

	if err := ioutil.WriteFile(destPath, data, 0644); err != nil {
		return err
	}

	return nil
}

func main() {
	key := []byte("0123456789abcdef") // 16字节长度的密钥
	srcPath := "encrypted.dat"
	destPath := "decrypted.txt"

	if err := decryptFile(key, srcPath, destPath); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	fmt.Println("Encryption completed successfully.")
}

```











